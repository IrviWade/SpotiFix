import "module:std" as std
import "module:spotube_plugin" as spotube

import { SpotifyGqlApi } from '../../dependencies/hetu_spotify_gql_client/lib/assets/hetu/spotify_gql_api_client.ht'
import { Converters } from '../converter/converter.ht'
import { SpotifyAuthEndpoint } from "./auth.ht"

var Timezone = spotube.Timezone
var StreamSubscription = std.StreamSubscription

class BrowseEndpoint {
  var client: SpotifyGqlApi
  var auth: SpotifyAuthEndpoint
  var _pendingAuthCallbacks: List

  construct (this.client, this.auth){
    _pendingAuthCallbacks = []
    
    // Listen for auth events and resolve all pending callbacks
    auth.authStateStream.listen((event){
      var t = event?["type"]
      if (t == "login" || t == "recovered" || t == "refreshed") {
        var callbacks = _pendingAuthCallbacks
        _pendingAuthCallbacks = []
        for (var cb in callbacks) {
          cb(true)
        }
      }
    })
  }

  fun _spTCookieFromCredentials(creds: Map) -> string {
    var cookies = creds?["cookies"]
    if (cookies == null) {
      throw { message: "Missing cookies. Please log in again." }
    }

    var spTCookies = cookies.where((c) => c["name"] == "sp_t").toList()

    if (spTCookies.isEmpty) {
      throw { message: "Missing sp_t cookie. Please log in via the web player." }
    }

    return spTCookies.elementAt(0)["value"]
  }

  fun _withValidCredentials(run: (spTCookie: string) -> Future) {
    // Already authenticated? Just run immediately.
    if (auth.isAuthenticated()) {
      return run(_spTCookieFromCredentials(auth.credentials))
    }

    // Not authenticated - open login if not already open, then wait for auth event.
    var isFirstWaiter = _pendingAuthCallbacks.isEmpty
    
    // Create a Future-like construct using callback
    var result
    var resolved = false
    
    _pendingAuthCallbacks.add((success){
      if (resolved) return
      resolved = true
      
      if (auth.isAuthenticated()) {
        result = run(_spTCookieFromCredentials(auth.credentials))
      }
    })
    
    // Only the first waiter opens the auth window
    if (isFirstWaiter) {
      auth.authenticate()
    }
    
    // Return a polling future that waits for resolved + result
    return _pollForResult((){
      return resolved && result != null
    }, (){
      return result
    })
  }
  
  fun _pollForResult(check: () -> bool, getResult: () -> any) {
    if (check()) {
      return getResult()
    }
    
    // Poll every 100ms using Timer-based approach
    return std.Future.delayed(std.Duration(milliseconds: 100), (){
      return _pollForResult(check, getResult)
    })
  }

  fun sections({offset: int, limit: int}) {
    return _withValidCredentials((spTCookie){
      return Timezone.getLocalTimeZone().then((timeZone){
        return client.browse.home(
          timeZone: timeZone,
          spTCookie: spTCookie,
          limit: limit,
        ).then((sections){
          return {
            limit: limit ?? 20,
            nextOffset: null,
            hasMore: false,
            total: sections.length,
            items: sections.map((section) {            
              var playlists = section["items"].where((item) => item["objectType"] == "Playlist").toList()
              var albums = section["items"].where((item) => item["objectType"] == "Album").toList()
              var artists = section["items"].where((item) => item["objectType"] == "Artist").toList()
              
              return {
                id: section["id"],
                title: section["title"],
                externalUri: section["external_urls"]["spotify"] ?? "https://open.spotify.com/section/${section["id"]}",
                browseMore: true,
                items: [
                  ...Converters.simplePlaylistsFromLibraryV3(playlists),
                  ...Converters.simpleAlbums(albums),
                  ...Converters.fullArtists(artists),
                ],
              }.toJson()
            }).toList()
          }.toJson()
        })
      })
    })
  }

  fun sectionItems(id: string, {offset: int, limit: int}) {
    return _withValidCredentials((spTCookie){
      return Timezone.getLocalTimeZone().then((timeZone) {
        return client.browse.homeSection(
          id, 
          timeZone: timeZone,
          spTCookie: spTCookie,
          offset: offset,
          limit: limit,
        ).then((section){
          return Converters.paginated(
            section,
            (items) {
              var playlists = section["items"].where((item) => item["objectType"] == "Playlist").toList()
              var albums = section["items"].where((item) => item["objectType"] == "Album").toList()
              var artists = section["items"].where((item) => item["objectType"] == "Artist").toList()

              return [
                  ...Converters.simplePlaylistsFromLibraryV3(playlists),
                  ...Converters.simpleAlbums(albums),
                  ...Converters.fullArtists(artists),
                ]
            }
          )
        })
      })
    })
  }
}